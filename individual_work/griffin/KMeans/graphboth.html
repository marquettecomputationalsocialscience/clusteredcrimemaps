<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Potential Bias Graph</title>
    <script src='d3/d3.js'></script>
    <link rel="stylesheet" href="billboard/billboard.css">
    <script src='billboard/billboard.js'></script>
    <script src='cityLimit.js'> </script>
    <script src='zipcodes.js'></script>
    <script src='turf.min.js'></script>


</head>
<style>
    div.tooltip {
        position: absolute;
        text-align: left;
        width: 200px;
        height: 60px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
        line-height: 40%
    }

    div.graphDisplay {
        position:absolute;
        left:960px;
        top:10px;
        height:150px;
        width:150px;
    }

    svg {
        position: absolute;
    }


    .hull {
        stroke: black;
        stroke-width: 2px;
        stroke-linejoin: round;
        opacity: .3;
        pointer-events: none;
    }
    /* .tick text{
          font-size:13px;
      }*/




    .bar {
        fill: steelblue;
    }

</style>
<body>

<script src='all.js'></script>
<script type="text/javascript">
    var results_data = [];

    for(var h=0;h<24;h++) {
        var both = complete_data[h];


        function colorAssign(d,currentK){
            if(currentK.includes('K0')){
                return '#900';
            }
            var val = d['properties'][currentK];
            return colorList[val];
        }

        function setAllColors(crime_points, currentK){

            crime_points.selectAll('path').transition()
                .duration(400)
                .each(function(d){
                    d3.select(this).attr('fill', colorAssign(d, currentK));
                });
        }


        function hullCreation(child, k, crime_points, currentK, label) {
            child.selectAll('.hull').remove();

            for (var i = 0; i < k; i++) {

                var points = [];
                crime_points.selectAll('path')
                    .each(function (d) {
                            var cluster = d['properties'][currentK];
                            if (cluster === i) {
                                var coord = d['properties']['Location'];
                                coord = coord.reverse();
                                points.push(coord);
                            }
                        }
                    );
                var hullPoints = d3.polygonHull(points);

                var mappedPoints = hullPoints.map(function (d) {
                    return albersProjection(d);
                });

                while (mappedPoints[0][0] > 2000) {
                    points = [];
                    crime_points.selectAll('path')
                        .each(function (d) {
                                var cluster = d['properties'][currentK];
                                if (cluster === i) {
                                    var coord = d['properties']['Location'];
                                    coord = coord.reverse();
                                    points.push(coord);
                                }
                            }
                        );
                    hullPoints = d3.polygonHull(points);


                    mappedPoints = hullPoints.map(function (d) {
                        return albersProjection(d);
                    });
                }

                var hull = child.append('path')
                    .attr('class', 'hull')
                    .datum(mappedPoints)
                    .attr('d', function (d) {
                        return 'M' + d.join('L') + 'Z';
                    })
                    .attr('fill', colorList[i])
                    .attr('id', label + i)
                    .style('opacity', 0);

                hull.transition()
                    .duration(400)
                    .style('opacity', .3);

            }

        }

        function overlapCalculation(cluster, polygon){
            return turf.intersect(cluster,polygon);
        }


        function calculateConfusionMatrix(hullNum, currentK){
            var TN=0,FP=0,FN=0,TP=0;

            crime_points.selectAll('path')
                .each(function(d){
                    var e_val = d['properties']['e_cluster' + currentK];
                    var g_val = d['properties']['g_cluster' + currentK];
                    if((e_val === g_val) && (e_val === hullNum)){
                        TP += 1;
                    } else if (e_val === hullNum && g_val !== hullNum){
                        FP += 1;
                    } else if (e_val !== hullNum && g_val === hullNum){
                        FN += 1;
                    } else {
                        TN += 1;
                    }
                });
            return [TN,FP,FN,TP];
        }


        function calculateProbabiltyDistribution(results){
            var sum = d3.sum(results);
            var probability = results.map(function(d){
                return d/sum;
            });
            return probability;

        }

        function calculateConfusionScore(geo_hull, k){

            var composition_list = [];
            var e_total_list = new Array(k).fill(0);
            var frequency_list = new Array(k).fill(0);
            var total = 0;
            for (var j = 0; j < both.features.length; j++) {
                var d = both.features[j];
                    var e_val = d['properties']['e_cluster' + 'K' + k];
                    var g_val = d['properties']['g_cluster' + 'K' + k];
                    e_total_list[e_val] += 1;

                    if(g_val === geo_hull){

                        total += 1;
                        if (!composition_list.includes(e_val)){
                            composition_list.push(e_val);
                        }
                        frequency_list[e_val] += 1;
                    }
            }


            var sum = 0;
            for (var i =0; i < composition_list.length; i++){
                var index = composition_list[i];

                var euclid_percent = frequency_list[index] / e_total_list[index];
                var geodesic_weight = frequency_list[index] / total;
                sum += (euclid_percent * geodesic_weight);

            }

            return (1 - sum);
        }

        function demographicCalculation(data){
            var results = [0,0,0,0,0,0,0];
            var hull_polygon=turf.lineStringToPolygon(turf.lineString(data));

            for (var i = 0; i < zipcodes.features.length; i++){
                var a = zipcodes.features[i];

                var overlap = overlapCalculation(hull_polygon,a['geometry']);

                if (overlap) {
                    var over_area = turf.area(overlap);
                    var zip_area = turf.area(a);
                    var percent_overlap = over_area / zip_area;
                    results[0] += a['properties']['White'] * percent_overlap;
                    results[1] += a['properties']['Black or African American'] * percent_overlap;
                    results[2] += a['properties']['American Indian and Ala Native'] * percent_overlap;
                    results[3] += a['properties']['Asian'] * percent_overlap;
                    results[4] += a['properties']['Native Hawaiian/other Pac Isl'] * percent_overlap;
                    results[5] += a['properties']['Multiple Race'] * percent_overlap;
                    results[6] += a['properties']['Other Race'] * percent_overlap;
                }
            }

            results = results.map(Math.floor);
            return results;
        }

        function dataAggregate(val) {
            var sum =0;
            for (var i =0; i < val; i++){
                var k = val;
                var geo_hull = i;
                var points = [];

                var composition_list = [];
                var e_total_list = new Array(k).fill(0);
                var frequency_list = new Array(k).fill(0);
                var total = 0;
                for (var h = 0; h < both.features.length; h++) {
                    var d = both.features[h];
                    var e_val = d['properties']['e_cluster' + 'K' + k];
                    var g_val = d['properties']['g_cluster' + 'K' + k];
                    e_total_list[e_val] += 1;

                    if(g_val === geo_hull){

                        total += 1;
                        if (!composition_list.includes(e_val)){
                            composition_list.push(e_val);
                        }
                        frequency_list[e_val] += 1;
                        points.push(d['geometry']['coordinates']);
                    }
                }


                var csum = 0;
                for (var l =0; l < composition_list.length; l++){
                    var index = composition_list[l];

                    var euclid_percent = frequency_list[index] / e_total_list[index];
                    var geodesic_weight = frequency_list[index] / total;
                    csum += (euclid_percent * geodesic_weight);

                }

                var confusion = 1 - csum;


                var hull = d3.polygonHull(points);
                var census = demographicCalculation(hull);
                var minority_prob = d3.sum(census.map(function(d){
                    return d/ d3.sum(census);
                }).slice(1));
                sum += minority_prob * confusion;
                console.log(confusion);
            }

            var result = sum / val;

            results_data.push(result);

        }

        dataAggregate(4);


    }

    var t_data = results_data.slice(0,12);
    var m_data = results_data.slice(12);



    console.log(t_data);
    console.log(m_data);
    var full_names = ['January', 'February', 'March', 'April', 'May',
        'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var short_names = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June',
        'July', 'Aug', 'Sept', 'Oct', 'Nov', 'Dec'];

    t_data.unshift('Theft');
    m_data.unshift('Motor Vehicle Theft');

    d3.select('body')
        .append('div')
        .attr('id','chart');

    var chart = bb.generate({
        'size':{
            'height': 700,
            'width': 800
        },
        'data': {
            'columns': [
                t_data,
                m_data
            ]
        },
        'axis':{
            'x':{
                label: {
                    text:'Month',
                    position:'outer-center'
                },
                'type':'category',
                'categories':full_names,
                tick:{
                    centered:true,
                    multiline:true,
                    fit:true
                }
//                'height':20
            },
            y:{
                label:{
                    text: 'Potential Bias Index',
                    position: 'outer-middle'
                }
            }


        },
        color:{
            pattern:[
                '#3949ab',
                '#d81b60',
                '#e53935',
                '#43a047',
                '#d81b60',
                '#8e24aa',
                '#5e35b1',
                '#3949ab',
                '#1e88e5',
                '#039be5',
                '#00acc1',
                '#00897b',
                '#43a047',
                '#7cb342',
                '#c0ca33',
                '#fdd835',
                '#ffb300',
                '#fb8c00',
                '#f4511e',
                '#6d4c41',
                '#757575',
                '#546e7a'
            ]
        },
        'bindto': '#chart'
    });









</script>
</body>
</html>
